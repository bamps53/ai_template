# [Python]

## コーディング規約とスタイル
- **PEP 8準拠**: コードのフォーマットはPEP 8に従ってください。`flake8`や`black`,`isort`などのツールを利用して一貫性を保ちましょう。
- **型ヒント (Type Hints)**: 型ヒントを使用してコードの可読性と静的解析の助けにしましょう。
    - 例: `def my_function(param: str) -> bool:`
- **Docstrings**: すべての公開モジュール、関数、クラス、メソッドには、その目的、引数、戻り値を説明するdocstringを記述してください (例: Googleスタイル, NumPyスタイル, reStructuredText)。
- **f-stringの使用**: 文字列フォーマットには可読性が高く効率的なf-stringを優先的に使用してください。
    - 例: `name = "World"; message = f"Hello, {name}!"`
- **命名規則**: 変数名や関数名はスネークケース (`snake_case`)、クラス名はキャメルケース (`ClassName`) を使用してください。

## エラーハンドリングと堅牢性
- **具体的な例外処理**: `except Exception:` のような汎用的な例外補足は避け、処理できる具体的な例外を補足するようにしてください。
- **`try-except-else-finally` の適切な使用**: `else`ブロックは`try`ブロックで例外が発生しなかった場合に実行するコードを記述し、`finally`ブロックは例外の有無に関わらず必ず実行するクリーンアップ処理を記述します。

## セキュリティ
- **入力値の検証**: 外部からの入力値（ユーザー入力、APIレスポンスなど）は常に検証し、サニタイズしてください。
- **`eval()`や`exec()`の慎重な使用**: 動的なコード実行はセキュリティリスクを伴うため、極力避けるか、信頼できる入力に対してのみ使用してください。

# [TypeScript]

## 型システムと厳格性
- **`any`型の回避**: `any`の使用は最小限に留め、可能な限り具体的な型（`string`, `number`, `boolean`, `interface`, `type`エイリアスなど）を使用してください。`unknown`型がより安全な代替となる場合があります。
- **`strictNullChecks`の有効化**: `tsconfig.json`で`strictNullChecks: true`を設定し、`null`と`undefined`の扱いを厳格にすることで、実行時エラーを減らしましょう。
- **インターフェース (interface) と型エイリアス (type)**: オブジェクトの形状を定義するにはインターフェースを、より複雑な型やプリミティブのエイリアスには型エイリアスを適切に使い分けてください。
- **ユーティリティ型 (Utility Types) の活用**: `Partial<T>`, `Readonly<T>`, `Pick<T, K>`, `Omit<T, K>`などの組み込みユーティリティ型を活用して、既存の型から新しい型を効率的に作成しましょう。

## コーディング規約とスタイル
- **ESLintとPrettierの導入**: コードの一貫性を保ち、潜在的なバグを早期に発見するために、ESLintとPrettierを設定し、CIで実行するようにしましょう。
- **命名規則**: 変数名や関数名はキャメルケース (`camelCase`)、クラス名やインターフェース名はパスカルケース (`PascalCase`)、定数は大文字スネークケース (`UPPER_SNAKE_CASE`) を推奨します。
- **モジュール性**: ファイルやモジュールは単一責任の原則に従い、適切に分割してください。明確な`export`と`import`文を使用しましょう。

## 非同期処理
- **`async/await`の優先**: Promiseを扱う際は、可読性の観点から`.then().catch()`よりも`async/await`構文を優先的に使用しましょう。
- **`async`関数のエラーハンドリング**: `async`関数内では`try...catch`ブロックを使用して、Promiseのrejectを適切にハンドリングしてください。トップレベルでのPromiseの`unhandledrejection`を避けるようにしましょう。
